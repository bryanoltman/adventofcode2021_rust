use std::{collections::HashMap, hash::Hash, vec};

struct Input {
    pub lines: Vec<Line>,
}

#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
struct Point {
    pub x: i32,
    pub y: i32,
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
struct Line {
    pub start: Point,
    pub end: Point,
}

#[aoc2021::main(05)]
fn main(input: &str) -> (u32, u32) {
    let parsed_input = parse_input(input);
    (part1(&parsed_input), part2(&parsed_input))
}

fn input_line_to_points(line: &str) -> Line {
    let mut split = line.split("->");

    let start = split
        .next()
        .unwrap()
        .trim()
        .split(",")
        .map(|s| s.parse::<i32>().unwrap())
        .collect::<Vec<i32>>();

    let end = split
        .next()
        .unwrap()
        .trim()
        .split(",")
        .map(|s| s.parse::<i32>().unwrap())
        .collect::<Vec<i32>>();

    Line {
        start: Point {
            x: start[0],
            y: start[1],
        },
        end: Point {
            x: end[0],
            y: end[1],
        },
    }
}

fn parse_input(input: &str) -> Input {
    Input {
        lines: input.lines().map(input_line_to_points).collect(),
    }
}

// generated by copilot
fn points_on_line(line: &Line) -> Vec<Point> {
    let mut points = vec![];

    let mut x = line.start.x;
    let mut y = line.start.y;

    let dx = line.end.x - line.start.x;
    let dy = line.end.y - line.start.y;

    let mut x_inc = 1;
    let mut y_inc = 1;

    if dx < 0 {
        x_inc = -1;
    }

    if dy < 0 {
        y_inc = -1;
    }

    let dx = dx.abs();
    let dy = dy.abs();

    let mut err = dx - dy;

    loop {
        points.push(Point { x, y });

        if x == line.end.x && y == line.end.y {
            break;
        }

        let e2 = 2 * err;

        if e2 > -dy {
            err -= dy;
            x += x_inc;
        }

        if e2 < dx {
            err += dx;
            y += y_inc;
        }
    }

    points
}

fn line_is_horizontal(line: &Line) -> bool {
    line.start.y == line.end.y
}

fn line_is_vertical(line: &Line) -> bool {
    line.start.x == line.end.x
}

fn part1(input: &Input) -> u32 {
    let points_map = input
        .lines
        .iter()
        .filter(|line| line_is_horizontal(line) || line_is_vertical(line))
        .map(|l| points_on_line(&l))
        .fold(HashMap::new(), |mut acc: HashMap<Point, u32>, points| {
            for point in points {
                let counter = acc.entry(point).or_insert(0);
                *counter += 1;
            }
            acc
        });

    points_map.values().filter(|v| **v > 1).count() as u32
}

fn part2(input: &Input) -> u32 {
    let points_map = input.lines.iter().map(|l| points_on_line(&l)).fold(
        HashMap::new(),
        |mut acc: HashMap<Point, u32>, points| {
            for point in points {
                let counter = acc.entry(point).or_insert(0);
                *counter += 1;
            }
            acc
        },
    );

    points_map.values().filter(|v| **v > 1).count() as u32
}

#[cfg(test)]
mod tests {
    use super::*;

    const INPUT: &str = "0,9 -> 5,9
8,0 -> 0,8
9,4 -> 3,4
2,2 -> 2,1
7,0 -> 7,4
6,4 -> 2,0
0,9 -> 2,9
3,4 -> 1,4
0,0 -> 8,8
5,5 -> 8,2";

    #[test]
    fn test_line_to_points() {
        assert_eq!(
            input_line_to_points("0,9 -> 5,9"),
            Line {
                start: Point { x: 0, y: 9 },
                end: Point { x: 5, y: 9 }
            }
        );
    }

    #[test]
    fn test_parse_input() {
        let parsed = parse_input(INPUT);
        assert_eq!(
            parsed.lines[0],
            Line {
                start: Point { x: 0, y: 9 },
                end: Point { x: 5, y: 9 }
            }
        );
        assert_eq!(
            parsed.lines[1],
            Line {
                start: Point { x: 8, y: 0 },
                end: Point { x: 0, y: 8 }
            }
        );
        assert_eq!(
            parsed.lines[2],
            Line {
                start: Point { x: 9, y: 4 },
                end: Point { x: 3, y: 4 }
            }
        );
        assert_eq!(
            parsed.lines[3],
            Line {
                start: Point { x: 2, y: 2 },
                end: Point { x: 2, y: 1 }
            }
        );
        assert_eq!(
            parsed.lines[4],
            Line {
                start: Point { x: 7, y: 0 },
                end: Point { x: 7, y: 4 }
            }
        );
        assert_eq!(
            parsed.lines[5],
            Line {
                start: Point { x: 6, y: 4 },
                end: Point { x: 2, y: 0 }
            }
        );
        assert_eq!(
            parsed.lines[6],
            Line {
                start: Point { x: 0, y: 9 },
                end: Point { x: 2, y: 9 }
            }
        );
        assert_eq!(
            parsed.lines[7],
            Line {
                start: Point { x: 3, y: 4 },
                end: Point { x: 1, y: 4 }
            }
        );
        assert_eq!(
            parsed.lines[8],
            Line {
                start: Point { x: 0, y: 0 },
                end: Point { x: 8, y: 8 }
            },
        );
        assert_eq!(
            parsed.lines[9],
            Line {
                start: Point { x: 5, y: 5 },
                end: Point { x: 8, y: 2 }
            },
        );
    }

    #[test]
    fn test_points_on_horizontal_line() {
        let line = Line {
            start: Point { x: 0, y: 0 },
            end: Point { x: 3, y: 0 },
        };
        let points = points_on_line(&line);
        assert_eq!(
            points,
            vec![
                Point { x: 0, y: 0 },
                Point { x: 1, y: 0 },
                Point { x: 2, y: 0 },
                Point { x: 3, y: 0 },
            ]
        );
    }

    #[test]
    fn test_points_on_vertical_line() {
        let line = Line {
            start: Point { x: 0, y: 0 },
            end: Point { x: 0, y: 3 },
        };
        let points = points_on_line(&line);
        assert_eq!(
            points,
            vec![
                Point { x: 0, y: 0 },
                Point { x: 0, y: 1 },
                Point { x: 0, y: 2 },
                Point { x: 0, y: 3 },
            ]
        );
    }

    #[test]
    fn test_part1() {
        assert_eq!(part1(&parse_input(INPUT)), 5);
    }

    #[test]
    fn test_part2() {
        assert_eq!(part2(&parse_input(INPUT)), 12);
    }
}
